#include "ECS/Module.hpp"
#include "Exception/Module.hpp"
#include "FileManager/Module.hpp"
#include "Logger/Module.hpp"
#include "Mojula/Module.hpp"
#include "Profiler/Module.hpp"
#include "Time/Module.hpp"
#include "Window/Module.hpp"

#include <future>
#include <thread>
#include <vector>

int main()
{
	using namespace Light;

	try
	{
		std::vector<Module*> modules         = {};
		std::vector<Module*> gameModules     = {};
		std::vector<Module*> renderModules   = {};
		std::vector<Module*> syncableModules = {};

		////////////////////////////////////////////////////////////////
		/// Create the modules (they get initialized in construct time)
		{
			// @todo This piece of code should be generated by a build script so we can customize which modules needs to be loaded
			modules.push_back(new LoggerModule());
			modules.push_back(new TimeModule());
			modules.push_back(new WindowModule());
			modules.push_back(new FileManagerModule());
			modules.push_back(new ProfilerModule());
			modules.push_back(new ECSModule());

			for (auto* module : modules)
			{
				switch (module->GetTickType())
				{
				case Module::TickType::eNone:
					break;

				case Module::TickType::eGameThread:
					gameModules.push_back(module);
					break;

				case Module::TickType::eRenderThread:
					renderModules.push_back(module);
					break;

				default:
					ASSERT(false, "Invalid module tick type");
				}

				if (module->IsSyncable())
				{
					syncableModules.push_back(module);
				}
			}
		}

		////////////////////////////////////////////////////////////////
		/// Main loop
		{
			PROFILE_SCOPE("Frame");

			std::atomic<bool> game_a   = false;
			std::atomic<bool> game_b   = false;
			std::atomic<bool> render_a = false;
			std::atomic<bool> render_b = false;

			bool shouldClose = false;

			auto gameThread = std::async(std::launch::async, [&]() {
				while (!shouldClose)
				{
					for (Module* module : gameModules)
					{
						module->OnTick();
					}

					game_b = true;
					while (!game_a)
					{
						std::this_thread::yield();
					}
					game_a = false;
				} });

			auto renderThread = std::async(std::launch::async, [&]() {
				while (!shouldClose)
				{
					for (Module* module : renderModules)
					{
						module->OnTick();
					}

					render_b = true;
					while (!render_a)
					{
						std::this_thread::yield();
					}
					render_a = false;
				}
			});

			while (!shouldClose)
			{
				PROFILE_SCOPE("Sync");

				while (!game_b && !render_b)
				{
					std::this_thread::yield();
				}

				game_b   = false;
				render_b = false;

				for (Module* module : syncableModules)
				{
					module->OnSync();
					shouldClose = module->HasRequestedAppTermination();
				}

				game_a   = true;
				render_a = true;
			}

			renderThread.wait();
			gameThread.wait();
		}

		////////////////////////////////////////////////////////////////
		/// Gracefully destroy everything
		{
			for (uint64_t i = modules.size(); i-- > 0;)
			{
				delete modules[i];
			}
		}
	}
	catch (Exception exception)
	{
		////////////////////////////////////////////////////////////////
		/// Save user progress if applicable

		////////////////////////////////////////////////////////////////
		/// Show/save information about what went wrong, where and when

		return -1;
	}

	return 0;
}
